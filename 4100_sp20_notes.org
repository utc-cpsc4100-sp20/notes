#+TITLE: Course Notes: CPSC 4100 Spring 2020
#+AUTHOR: Craig Tanis
#+LATEX_CLASS: article
#+LATEX_HEADER: \usepackage[cm]{fullpage}\setlength{\parindent}{0pt}\setlength{\parskip}{10pt}
#+LATEX_HEADER:\usepackage[labelformat=empty]{caption}
#+OPTIONS: author:nil date:nil


#+BEGIN_EXPORT LaTeX
\thispagestyle{empty}
\lstdefinelanguage{shell}{}
\lstdefinelanguage{scheme}{}
\lstdefinelanguage{text}{}
\lstset{upquote=true}
#+END_EXPORT



* Languages
** C
   - originally 1973
   - Dennis Ritchie (The R in K&R)
   - ANSI (American National Standards Institute) C standard since 1989
   - imperative: statements affect program state
   - structured: formal control structures / blocks
   - procedural: code organized into called procedures (subroutines)
   - static typing: data type property assigned at compile time
   - weakly typed (=void*=) : implicit type casting under some conditions
   - compiles all the way to the hardware (executables not portable)
   - allows for raw memory management and manipulation

   - modeled naturally on the standard /von Neumann machine/ architecture
     - CPU with registers, ALU, control unit
     - memory containing both instructions and data

*** hello world in C (the parts of)

    #+begin_src C
      #include <stdio.h>              /* preprocessor directive */

      int main(int argc, char *argv[]) /* program entry point with command line arguments */
      {
          printf("Hello World\n");    /* a subroutine that does IO -- declared in stdio.h */
          return 0;                   /* return code from main -> exit code for program */
      }

    #+end_src

*** C data types
    :  void
    :  char
    :  int
    :  float
    :  double
    :
    :  // these assume int
    :  short
    :  long
    :  signed
    :  unsigned
    :
    : // may be optimized by using read only memory
    : const
    : 
    : // no implementation-independent semantics
    : volatile

**** typedef
     syntactic renaming of a type

     : typedef unsigned int uint
     : typedef const double CONSTANT;

**** arrays
     : int values[10];  -->   int* values

     array lookups as math problems

     #+begin_src C
   int values[10];

   for (int i=0; i<10; i++)
   {
       printf("%d: %d\n", i, values[i]);
   }

   printf("set values[3]\n");
   /* type of values tells it how to interpret the 3 */
   ,*(values + 3) = 999;

   /* raw addresses */
   printf("set values[8]\n");
   ,*((int*)((void*)values + sizeof(int)*8))=1234;
     #+end_src





** C++
   - Bjarne Stroustrup
   - first appeared 1985; standardized in 1998
   - adds object oriented features, namespaces, generics, exceptions

*** hello world in C++

    #+begin_src c++
      #include <iostream>

      int main(int argc, char *argv[])
      {
          std::cout << "hello world" << std::endl;
          return 0;
      }

    #+end_src


*** Null-terminated strings
    String data is stored as an array of characters with the NULL character
    (ascii 0) indicating the end of the string.

    Many useful functions for dealing with data of this type are available in ~string.h~.


** Scheme

   A lexically scoped dialect of Lisp

   Strongly typed / dynamically typed.


*** data types
    + numbers:   ~1.0~, ~45~, ~8+3i~, ...
    + characters: ~#\x~
    + booleans: ~#t~  ~#f~  (note this is different than ~#\t~ and ~#\f~)
    + symbols: 'foo
    + strings: "hello"
    + vectors: ~#(1 2 3)~  -- like a fixed-length list
          
*** procedures

    + created with a ~lambda~ expression

      #+begin_src scheme
      (lambda (a b)
        (+ a b))                              ;add a and b
      #+end_src

    + bound to a variable with the ~define~ special form

      #+begin_src scheme
        (define add2 (lambda (a b)
                       (+ a b)))
      #+end_src

*** function currying

    concept from the lambda calculus where procedures may only take a single
    parameter.

    f(a,b) = {f'(a)}(b)

    For example, if lambdas could only take one argument:
    #+begin_src scheme
      (define add (lambda (a) (lambda (b) (+ a b))))
      ((add 5) 10)
    #+end_src




*** read from user
    + ~(read)~ -> symbol
    + ~(use-modules (ice-9 readline))  (readline "enter a string")~ -> string

   
*** control structures

    + if/else
      + eq? equal? ...
    + when/unless
    + loops do exist:  while / do
    + begin  (implied within lambda)
     

   
*** working with lists/pairs

    + cons
    + car / cdr
    + car, caar,  cddr, cadr, etc.
    + list / pair procedures
    + memq , assoc


    ~cons~ creates a new list with the first parameter stuck on the beginning of
    the second.

    #+begin_src text
      scheme@(guile-user)> (cons 'a '(1 2 3))
      $2 = (a 1 2 3)
    #+end_src

    ~car~ returns the first item in a list.  ~cdr~ returns the rest of the list,
    after the ~car~

    #+begin_src text
      scheme@(guile-user)> (car '(this that the other))
      $3 = this
      scheme@(guile-user)> (cdr '(this that the other))
      $4 = (that the other)
    #+end_src

   
*** recursion as iteration
    + factorial
    + map, filter


*** binding local variables introduce new variables
    + let, let*, letrec, letrec*
      let* -> nested lets
    + nested define -> letrec


*** closures
    A function with environment containing free variables bound in some other
    /environment/ that existed when the function was created.

    #+begin_src scheme
      (define (make-adder base)
        (lambda (i)
          (+ base i)))
    #+end_src

*** imperatives
    + ~set!~ (and many other variants)
   
*** lambda as object
    + closures and imperatives together give object-like functionality
#    + see [[./scheme/object.scm]]



* General Concepts

** Binding Times
   The act of associating /names/ with properties (data type, address, value)
   is called /binding/, and different properties are bound at different
   times.

   #+begin_src C
   #include <math.h>


     void main() 
     {
      
     int i;
     double sum=0;

         for (i=1; i<100; i++)
              sum += sqrt(i);
     }
   #+end_src


   - *language definition time*
              
     meaning of keywords is bound -- all implementations must behave the
     same way (void, for)

   - *language implementation time*

     e.g. the range of values for ~int~ is implementation dependent.  (not the 
     same in java)

   - *compile time*

     - data type for ~i~ is bound here.  (static typing)
     - details of ~sqrt~ interface (declaration in math.h)

   - *link time*

     definition of ~sqrt~

   - *load time*

     memory address for all of these symbols

   - *runtime*

     ~i~ takes on a sequence of values


   - early binding : before runtime   / late binding == runtime binding

   - not all language systems use all times (interpreters are not compiled)


** Parameter Passing Semantics

*** Definitions

    + formal parameters (specified in subroutine)
    + actual parameters (passed to subroutine)
    + the call stack

*** parameter /correspondence/
    + java and C use positional parameters
    + other languages may have keyword parameters
    + default parameters (C++ has this)

**** variable arguments in C
     processed with system calls


*** Call-by-value
     + formal parameters are local variables in the stack frame (aka
       /activation record/) of the called method
     + initialized with the value of the corresponding actual parameter
     + variables used in calling function cannot be directly modified since
       only the values are passed (pointers & references complicate this)
       

     
*** Call-by-reference
    The lvalue of the actual parameter is computed before the method executes.
    Formal parameters are replaced with actual parameter's lvalue.
    Effectively, the formal parameters become aliases for the actual
    parameters.    

*** Call-by-macro-expansion
    + formal parameters replaced with text of actual parameters
    + macro call replaced with expanded macro

**** variable capture
     For a given code snippet
     + *free variables* have no binding (are not associated with a specific
       memory location)
     + *bound variables* do
     + Macro expansion can cause free variables to become bound inside the
       macro expansion -- this has undefined semantics and will result in
       errors
       (see the SWAP exmaple)

       
*** Call-by-name

     Formal parameters are substituted (in a capture-avoiding way) with "text"
     of actual parameters.

     Also: *call-by-need* semantics: this is done in a memoized way (values are
     cached so it should be faster for certain applications)


** Parameter evaluation
   + applicative order: parameters are evaluated before subroutine is called
     (this is typical for C, Java, scheme...)
   + normal order: actual parameters are substituted into subroutine body and
     evaluated after subroutine call begins
     - see, [[Call-by-name]]



** Typing Systems

    - rules surrounding the binding of data type to variables and expressions

    - statically typed -- data types bound at compile time

    - type safety: how aggressively does the language apply typing rules to
      force you to write safe, good code

      - strongly typed <---> weakly typed

        C is (relatively) weakly typed because we can throw away type
        information by casting to ~void*~

** Definitions

*** statements vs. expressions
    - a statement is a executable step in the algorithm
      + the building block of an algorithm

    - an expression is anything with a value (can be evaluated)

*** lvalues and rvalues
    Every expression is either an lvalue or rvalue
    + rvalue's are temporary and have the lifetime of the corresponding expression
    + lvalue's persist beyond the expression
      - variables (anything with a name)

    + C has the ability to convert between the two in a manner


